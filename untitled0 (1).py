# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QBLdfTIziGQswR_BmVlH6I9s9CcSSc35
"""

btc_price = fetch_crypto_price('BTC/USD', 'kraken')
print('Bitcoin Price (BTC/USD):')
print(btc_price)

!pip install ccxt pandas

#@title Trading Bot Parameters Form
#@markdown ---
#@markdown ### Configure your trading bot parameters below:

coin = "BTC/USD" #@param {type:"string", label:"Trading Pair (e.g., BTC/USD, ETH/USD)"}
exchange = "kraken" #@param {type:"string", label:"Exchange (e.g., kraken, binance)"}
num_candles = 100 #@param {type:"slider", min:20, max:500, step:10, label:"Number of Candles (for SMA)"}
buy_threshold = 0.97 #@param {type:"slider", min:0.85, max:0.99, step:0.01, label:"Buy Threshold (3% = 0.97)"}
sell_threshold = 1.03 #@param {type:"slider", min:1.01, max:1.15, step:0.01, label:"Sell Threshold (3% = 1.03)"}

print("\nðŸ¤– Trading Bot Configuration Loaded!")
print(f"Coin: {coin}")
print(f"Exchange: {exchange}")
print(f"Number of Candles: {num_candles}")
print(f"Buy Threshold: {buy_threshold}")
print(f"Sell Threshold: {sell_threshold}")
print("Ready to run!\n")

!pip install ccxt

!pip install yfinance ccxt
import yfinance as yf
import ccxt

!pip install yfinance ccxt

# Cell 2: Function to fetch stock prices using yfinance

def fetch_stock_price(ticker, period='1d'):
    """
    Fetch current stock price for a given ticker symbol.

    Args:
        ticker (str): Stock symbol (e.g., 'AAPL', 'GOOGL', 'MSFT')
        period (str): Period for historical data ('1d', '1mo', '1y', etc.)

    Returns:
        dict: Contains current price, change, and percentage change
    """
    try:
        stock = yf.Ticker(ticker)
        hist = stock.history(period=period)

        if not hist.empty:
            current_price = hist['Close'].iloc[-1]
            previous_price = hist['Close'].iloc[0]
            change = current_price - previous_price
            pct_change = (change / previous_price) * 100 if previous_price != 0 else 0

            return {
                'ticker': ticker,
                'current_price': round(current_price, 2),
                'previous_price': round(previous_price, 2),
                'change': round(change, 2),
                'pct_change': round(pct_change, 2)
            }
        else:
            return {'error': f'No data found for {ticker}'}
    except Exception as e:
        return {'error': str(e)}

# Test the function with AAPL
aapl_price = fetch_stock_price('AAPL')
print('Apple Stock Price:')
print(aapl_price)

# Cell 3: Function to fetch cryptocurrency prices using CCXT
import ccxt

def fetch_crypto_price(symbol='BTC/USD', exchange_name='kraken'):
    """
    Fetch current cryptocurrency price using CCXT.
    Args:
        symbol (str): Trading pair (e.g., 'BTC/USDT', 'BTC/USD')
        exchange_name (str): Exchange name (e.g., 'binance', 'kraken')
    Returns:
        dict: Price data or error message
    """
    try:
        # Initialize the exchange
        exchange_class = getattr(ccxt, exchange_name)
        exchange = exchange_class()

        # Fetch the ticker data
        ticker = exchange.fetch_ticker(symbol)

        return {
            'symbol': symbol,
            'exchange': exchange_name,
            'current_price': ticker['last'],
            'bid': ticker['bid'],
            'ask': ticker['ask'],
            'high': ticker['high'],
            'low': ticker['low'],
            'timestamp': ticker['timestamp']
        }
    except ccxt.ExchangeNotAvailable as e:
        return {'error': f'Exchange {exchange_name} not available: {str(e)}'}
    except ccxt.InvalidPair as e:
        return {'error': f'Invalid pair {symbol} on {exchange_name}: {str(e)}'}
    except ccxt.NetworkError as e:
        return {'error': f'Network error with {exchange_name}: {str(e)}'}
    except ccxt.ExchangeError as e:
        return {'error': f'{exchange_name} exchange error: {str(e)}'}
    except Exception as e:
        return {'error': f'Error fetching {symbol} from {exchange_name}: {str(e)}'}

# Test the function
btc_price = fetch_crypto_price('BTC/USD', 'kraken')
print('Bitcoin Price (BTC/USD):')
print(btc_price)

# Cell 3: Function to fetch cryptocurrency prices using CCXT
import ccxt

def fetch_crypto_price(symbol='BTC/USD', exchange_name='kraken'):
    """
    Fetch current cryptocurrency price using CCXT.
    Args:
        symbol (str): Trading pair (e.g., 'BTC/USDT', 'BTC/USD')
        exchange_name (str): Exchange name (e.g., 'binance', 'kraken')
    Returns:
        dict: Price data or error message
    """
    try:
        # Initialize the exchange
        exchange_class = getattr(ccxt, exchange_name)
        exchange = exchange_class()

        # Fetch the ticker data
        ticker = exchange.fetch_ticker(symbol)

        return {
            'symbol': symbol,
            'exchange': exchange_name,
            'current_price': ticker['last'],
            'bid': ticker['bid'],
            'ask': ticker['ask'],
            'high': ticker['high'],
            'low': ticker['low'],
            'timestamp': ticker['timestamp']
        }
    except ccxt.ExchangeNotAvailable as e:
        return {'error': f'Exchange {exchange_name} not available: {str(e)}'}
    except ccxt.InvalidPair as e:
        return {'error': f'Invalid pair {symbol} on {exchange_name}: {str(e)}'}
    except ccxt.NetworkError as e:
        return {'error': f'Network error with {exchange_name}: {str(e)}'}
    except ccxt.ExchangeError as e:
        return {'error': f'{exchange_name} exchange error: {str(e)}'}
    except Exception as e:
        return {'error': f'Error fetching {symbol} from {exchange_name}: {str(e)}'}

# Cell 4: Buy-the-Dip Trading Logic (Placeholder)

def buy_the_dip_logic(current_price, moving_average, dip_threshold=0.95):
    """
    Placeholder function for buy-the-dip trading logic.

    Args:
        current_price (float): Current price of the asset
        moving_average (float): Moving average price (e.g., 20-day MA)
        dip_threshold (float): Threshold ratio (e.g., 0.95 = 5% below MA)

    Returns:
        dict: Buy signal (True/False) and reasoning
    """
    try:
        # Calculate the dip percentage
        dip_ratio = current_price / moving_average if moving_average > 0 else 1

        # Determine if we should buy
        should_buy = dip_ratio < dip_threshold

        return {
            'should_buy': should_buy,
            'current_price': current_price,
            'moving_average': moving_average,
            'dip_ratio': round(dip_ratio, 4),
            'threshold': dip_threshold,
            'reason': f'Price is {round((1 - dip_ratio) * 100, 2)}% below MA' if should_buy else 'Price above threshold'
        }
    except Exception as e:
        return {'error': str(e)}

# Test the function
test_result = buy_the_dip_logic(95, 100, 0.95)
print('Buy-the-Dip Logic Test:')
print(test_result)

# Cell 5: Sell-the-High Trading Logic (Placeholder)

def sell_the_high_logic(current_price, moving_average, high_threshold=1.05):
    """
    Placeholder function for sell-the-high trading logic.

    Args:
        current_price (float): Current price of the asset
        moving_average (float): Moving average price (e.g., 20-day MA)
        high_threshold (float): Threshold ratio (e.g., 1.05 = 5% above MA)

    Returns:
        dict: Sell signal (True/False) and reasoning
    """
    try:
        # Calculate the high percentage
        high_ratio = current_price / moving_average if moving_average > 0 else 1

        # Determine if we should sell
        should_sell = high_ratio > high_threshold

        return {
            'should_sell': should_sell,
            'current_price': current_price,
            'moving_average': moving_average,
            'high_ratio': round(high_ratio, 4),
            'threshold': high_threshold,
            'reason': f'Price is {round((high_ratio - 1) * 100, 2)}% above MA' if should_sell else 'Price below threshold'
        }
    except Exception as e:
        return {'error': str(e)}

# Test the function
test_result = sell_the_high_logic(110, 100, 1.05)
print('Sell-the-High Logic Test:')
print(test_result)

# Cell 8: Comprehensive Trading Logic with Form-Based Configuration
import ccxt
import pandas as pd

try:
    # Step 1: Fetch current price using FORM VARIABLES
    current_price_data = fetch_crypto_price(coin, exchange)

    # Check if there's an error in fetching price
    if 'error' in current_price_data:
        print("Error fetching current price:")
        print(current_price_data['error'])
    else:
        current_price = current_price_data['current_price']
        print(f"Current {coin} Price: ${current_price}")

        # Step 2: Fetch historical OHLCV data from exchange using FORM VARIABLES
        try:
            # Initialize exchange
            exchange_class = getattr(ccxt, exchange)
            exchange_obj = exchange_class()

            # Fetch OHLCV data using num_candles from form
            ohlcv = exchange_obj.fetch_ohlcv(coin, timeframe='1h', limit=num_candles)

            # Convert to pandas DataFrame
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

            # Step 3: Compute Simple Moving Average (SMA) of the last 20 closes
            closes = df['close'].values

            if len(closes) >= 20:
                sma_20 = pd.Series(closes).rolling(window=20).mean().iloc[-1]
                print(f"20-Period SMA: ${sma_20:.2f}")

                # Step 4: Apply trading logic using FORM VARIABLES (buy_threshold & sell_threshold)
                # Get trading decisions
                buy_decision = buy_the_dip_logic(current_price, sma_20, dip_threshold=buy_threshold)
                sell_decision = sell_the_high_logic(current_price, sma_20, high_threshold=sell_threshold)

                print(f"\n=== Trading Decisions ===")
                print(f"\nBuy-the-Dip Logic ({buy_threshold*100:.0f}% threshold):")
                print(buy_decision)
                print(f"\nSell-the-High Logic ({sell_threshold*100:.0f}% threshold):")
                print(sell_decision)

                # Summary
                print(f"\n=== Summary ===")
                if buy_decision.get('should_buy'):
                    print(f"âœ“ BUY SIGNAL: {coin} is {(1-buy_decision['dip_ratio'])*100:.2f}% below MA")

                if sell_decision.get('should_sell'):
                    print(f"âœ“ SELL SIGNAL: {coin} is {(sell_decision['high_ratio']-1)*100:.2f}% above MA")

                if not buy_decision.get('should_buy') and not sell_decision.get('should_sell'):
                    print(f"âŠ˜ HOLD: {coin} is within acceptable range")
            else:
                print(f"Not enough data. Got {len(closes)} candles, need at least 20.")

        except ccxt.ExchangeError as e:
            print(f"CCXT Exchange Error: {str(e)}")
        except Exception as e:
            print(f"Error fetching historical data: {str(e)}")

except Exception as e:
    print(f"Fatal error in trading logic: {str(e)}")
    import traceback
    traceback.print_exc()